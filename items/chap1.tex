\section{Основные понятия}

\subsection{Мотивация}
\label{section:generalsetting}

\subsection{Обозначения}

Ниже, мы введем обозначения, которые будут использоваться в этой работе.

\begin{itemize}
	\item $\sqcup$ обозначает дизъюнктивное объединение: используя $A\sqcup B$ вместо $A\cup B$, мы подчеркиваем, что множества $A$~и~$B$ не пересекаются. 
	\item $\oplus$ обозначает сложение по модулю~$2$.
	\item $[n]$ обозначает множество $\{1, 2, \dotsc, n\}$ (в частности, $[2^n] = \{1, 2, \dotsc, 2^n\}$).
	\item $o(\cdot), O(\cdot), \omega(\cdot), \Omega(\cdot), \Theta(\cdot)$ обозначают O~маленькое, 
	O~большое, омегу маленькую, омегу большую, и тету большую, соответственно.
	\item Для функций $f,g \colon \mathbb{Z}_{>0} \to \mathbb{R}_{>0}$, говоря, что $f(n) = 2^{O(g(n))}$, мы подразумеваем, что существует $\alpha > 0$ такая, что
	$f(n) \le 2^{\alpha \cdot g(n)}$ 
	для всех ~$n$.
	\item Для функций $f,g \colon \mathbb{Z}_{>0} \to \mathbb{R}_{>0}$, говоря, что $f(n) = 2^{o(g(n))}$,мы подразумеваем, что для любой константы $\alpha > 0$ существует натуральное число $n_0$ такое, что
	$f(n) \le 2^{\alpha \cdot g(n)}$ 
	для всех~$n > n_0$.
	\item Для функций $f,g \colon \mathbb{Z}_{>0} \to \mathbb{R}_{>0}$, говоря, что $f(n) = 2^{\Omega(g(n))}$, мы подразумеваем, что существует $\alpha > 0$ такая, что 
	$f(n) \ge 2^{\alpha \cdot g(n)}$ 
	для всех~$n$.
	\item Для функций $f,g \colon \mathbb{Z}_{>0} \to \mathbb{R}_{>0}$, говоря, что $f(n) = 2^{\omega(g(n))}$, мы подразумеваем, что для любой константы $\alpha > 0$ существует натуральное число $n_0$ такое, что 
	$f(n) \ge 2^{\alpha \cdot g(n)}$ 
	для всех~$n > n_0$.
\end{itemize}

\subsection{Вычисление Булевой Функции с Помощью КНФ}
Для булевой функции $f(x_1, \dotsc, x_n) \colon \{0,1\}^n \to \{0,1\}$, будем говорить, что КНФ~$F(x_1, \dotsc, x_n)$ \emph{вычисляет~$f$}, если $f \equiv F$, то есть, для всех $x_1, \dotsc, x_n \in \{0,1\}$, $f(x_1, \dotsc, x_n)=F(x_1, \dotsc, x_n)$.
Мы рассматриваем КНФ как набор дизъюнктов, и под \emph{размером} КНФ мы имеем ввиду число дизъюнктов.
Хорошо известно, что для любой функции~$f$ существует КНФ, вычисляющая эту функцию. Один из способов построить такую КНФ выглядит следующим образом: для каждого входа $x \in \{0,1\}^n$ такого, что $f(x)=0$, добавим в КНФ дизъюнкт длины~$n$, который не выполняется входом~$x$.

Этот метод не гарантирует, что полученная КНФ имеет минимальный размер: это было бы слишком хорошо, так как задача поиска КНФ минимального размера для булевой функции (данной в виде таблицы истинности) является NP-трудной, как доказал Масек~\cite{MasekNpComp} (смотри также \cite{DBLP:journals/siamcomp/AllenderHMPS08} и ссылки там).
Например, для функции $f(x_1,x_2)=x_1$, вышеизложенный метод производит КНФ $({x_1} \lor x_2) \land ({x_1} \lor \overline{x_2})$, в то время как сама функция $x_1$ уже в КНФ форме.

Доказано, что для многих функций, минимальная КНФ имеет экспоненциальный размер. Каноническим примером является функция четности $\PAR_n(x_1, \dotsc, x_n)=x_1 \oplus \dotsb \oplus x_n$. Важным свойством $\PAR_n$ является повышенная \emph{чувствительность}: меняя \emph{любой} бит во входе~$x \in \{0,1\}^n$, меняется значение всей функции~$\PAR_n(x)$. Именно из - за этого свойства не может быть маленькой КНФ, вычисляющей функцию $\PAR_n$.

\begin{lemma}\label{lemma:detparity}
	Минимальный размер КНФ, вычисляющей~$\PAR_n$ равен $2^{n-1}$.
\end{lemma}
\begin{proof}
	Верхняя оценка следует из метода, изложенного выше и факта, что $|\PAR_n^{-1}(0)|=2^{n-1}$.
	
	Нижняя оценка основана на факте, что любой дизъюнкт у КНФ~$F$ вычисляющей $\PAR_n$, должен содержать все переменные $x_1, \dotsc, x_n$.
	Действительно, если дизъюнкт $C \in F$ не зависит от переменной~$x_i$, то можно найти вход $x \in \{0,1\}^n$, который опровергает~$C$ (таким образом $F(x)=\PAR_n(x)=0$), и продолжит опровергать $C$ после инвертирования $x_i$. 
	Так как любой дихъюнкт~$F$ имееет ровно $n$ переменных, то он опровергает ровно один вход $x \in \{0,1\}^n$. Следовательно, $F$ должен содержать хотя бы  $|\PAR_n^{-1}(0)|=2^{n-1}$ дизъюнктов.
\end{proof}

\subsection{Кодирование Булевой Функции с Помощью КНФ}\label{sec:encodings}
Будем говорить, что КНФ~$F$ \emph{кодирует} булеву функцию $f(x_1, \dotsc, x_n)$, если следующие два условия выполняются.
\begin{enumerate}
	\item В дополнение ко входным битам $x_1, \dotsc, x_n$, $F$ также зависит от $s$~битов $y_1, \dotsc, y_s$, называемые \emph{недетерминированные входы} or \emph{дополнительные входы}.
	\item Для каждого $x \in \{0,1\}^n$, $f(x)=1$ тогда и только тогда, когда существует $y \in \{0,1\}^s$ такой, что $F(x,y)=1$. Другими словами, для всех $x \in \{0,1\}^n$,
	\begin{equation}\label{eq:enc}
		f(x) = \bigvee_{y \in \{0,1\}^s}F(x,y) \, .
	\end{equation}
\end{enumerate}
Такое представление булевой функции широко используется на практике при переводе задачи в КНФ.
Например, следующая КНФ кодирует $\PAR_4$:
\begin{multline}\label{eq:toyenc}
	(x_1 \lor x_2 \lor \overline{y_1}) \land (x_1 \lor  \overline{x_2} \lor y_1) \land (\overline{x_1} \lor x_2 \lor y_1) \land (\overline{x_1} \lor \overline{x_2} \lor \overline{y_1})
	\land
	(y_1 \lor x_3 \lor \overline{y_2}) \land\\ (y_1 \lor  \overline{x_3} \lor y_2) \land (\overline{y_1} \lor x_3 \lor y_2) \land (\overline{y_1} \lor \overline{x_3} \lor \overline{y_2})
	\land (\overline{x_4} \lor y_2) \land (x_4 \lor \overline{y_2}) \, .
\end{multline}

Этот пример обобщается следующим образом.
Чтобы закодировать $x_1 \oplus \dotsb \oplus x_n$ в виде КНФ,
надо ввести
$s \in \mathbb{Z}_{\ge 0}$~недетерминированных переменных $y_1, \dotsc, y_s$
и разделить множество входных переменных на дизъюнктивные множества размер не более $\lceil n/(s+1) \rceil$: $\{x_1, x_2, \dotsc, x_n\}=X_1 \sqcup X_2 \sqcup \dotsb \sqcup X_{s+1}$. 
Затем запишем следующие $s+1$ булевы функции в виде КНФ:
\begin{multline}\label{eq:blocks}
	\left(y_1 \equiv \bigoplus_{x \in X_1}x\right),
	\left(y_2 \equiv y_1 \oplus \bigoplus_{x \in X_2}x\right), \dotsc,\\
	\left(y_s \equiv y_{s-1} \oplus \bigoplus_{x \in X_s}x\right),
	\left(1 \equiv y_s \oplus \bigoplus_{x \in X_{s+1}}x\right).
\end{multline}
Каждая скобка может быть рассмотрена как булева функция от $k$ переменных, где $k \le \lceil n/(s+1) \rceil + 2$. Каждая такая функция имеет  $2^{k - 1}$ нулей, и поэтому может быть закодирована с помощью $2^{k - 1} \le 2^{\lceil n/(s+1) \rceil+2-1}$ дизъюнктов.
Значение для параметра~$s$ обычно определяется эксперементально. 
Например, Прествич~\cite{DBLP:journals/dam/Prestwich03} говорит, 
что лучший результат при решении задачи "minimal disagreement parity learning", используя САТ-солверы, основанные на локальном поиске, достигается при $s=10$.

Конструкция выше позволяет закодировать функцию четности в виде КНФ со следующей верхней границей на число дизъюнктов $m$, числе недетерминированных переменных~$s$ и ширину дизъюнктов~$k$.
The construction above 
allows one 
\begin{description}
	\item[Limited nondeterminism:] используя $s \in \mathbb{Z}_{\ge 0}$~недетерминированных переменных, можно закодировать функцию четности либо
	как КНФ с не более, чем 
	\begin{equation}\label{eq:upperm}
		m \le (s+1)2^{\lceil n/(s+1) \rceil+1} \le 4(s+1)2^{n/(s+1)}
	\end{equation}
	дизъюнктами, либо как~$k$-КНФ, где
	\begin{equation}\label{eq:upperk}
		k=2+{\lceil n/(s+1) \rceil} \le 3+n/(s+1) \, ,
	\end{equation}
	(следует из~\eqref{eq:blocks}).
\end{description}
	
%	\item[Unlimited nondeterminism:] one can encode parity 
%	as~a~CNF with at~most
%	\begin{equation}\label{eq:uppermtwo}
%		m \le 4n
%	\end{equation}
%	clauses
%	(to~do this, use $s=n-1$ nondeterministic variables; then, each of~$n$~functions in~\eqref{eq:blocks} can be~written in~CNF using at~most four clauses).

\subsection{Булевы Схемы и Преобразование Цейтина}\label{sec:tseitin}
Один из естественных способов получить КНФ кодировку булевой функции~$f$ следующий.
Возьмем булеву схему, вычисляющую~$f$ и применем преобразование Цейтина~\cite{zbMATH03325539}.
Мы опишем это преобразование, используя игрушечный пример.
Следующая схема вычисляет  $\PAR_{12}$ с помощью трех гейтов:
входные степени у $y_2$ и $y_3$ равны пяти, в то время как входная степень у $y_1$ равна четырем.
Схема имеем $12$ входов и $3$ гейта (один из них~---~выходной гейт), ее глубина равна трем.

\tikzstyle{gate} = [circle, draw, inner sep=0mm, minimum size=5mm]

\begin{center}
	\begin{tikzpicture}[yscale=1]
		%\draw[help lines] (1,0) grid (12,3);
		\begin{scope}[xscale=0.7, yscale=0.7]
			\foreach \n in {1,...,12}
			\node (\n) at (\n,0) {$x_{\n}$};
			\foreach \x/\y/\n/\l/\edges in {2.5/1/y1/y_1/{1,2,3,4}, 6.5/1.5/y2/y_2/{5,6,7,8,y1}, 10.5/2/y_3/y_3/{9,10,11,12,y2}} {
				\node[gate,label=above:$\l$] (\n) at (\x,\y) {$\oplus$};
				\foreach \i in \edges
				\draw[->] (\i) -- (\n);
			}
		\end{scope}
		\node[right, text width=42mm, inner sep=0mm] at (9,.75) {
			$y_1=x_1 \oplus x_2 \oplus x_3 \oplus x_4$\\
			$y_2=y_1 \oplus x_5 \oplus x_6 \oplus x_7 \oplus x_8$\\
			$y_3=y_2 \oplus x_9 \oplus x_{10} \oplus x_{11} \oplus x_{12}$
		};
	\end{tikzpicture}
\end{center}
%
Справа от схемы мы показываем функции, считающиеся каждым гейтом. 
Каждая строчка может быть переведена в КНФ.
Чтобы получить КНФ кодировку изначальной функции, надо добавить дизъюнкт $(y_3)$ к результирующей КНФ.
На самом деле, КНФ~\eqref{eq:blocks} получается ровно этим способом (после проталкивания значения выходного гейта).

\begin{observation}\label{obs:binarycircuits}
	Если функция $f \colon \{0,1\}^n \to \{0,1\}$ может быть вычислена схемой входной степени два с $g$ гейтами, тогда $f$ может быть закодирована как $3$-КНФ с $s=g$ недетерминированными переменными и $m=4g$ клозами.
\end{observation}
\begin{proof}
	Для каждого гейта~$g$ вычислим $g_1 \circ g_2$, где $\circ$~---~это бинарная булева операция, и $g_1$ вместе с $g_2$ являются прямыми предками $g$. Дальше, с помощью четырех $3$-дизъюнктов выразим факт, 
	что $g=g_1 \circ g_2$.
	(Более формально, можно рассмотреть булеву функцию $h(g, g_1, g_2)=[g=g_1 \circ g_2]$. 
	Тогда $|h^{-1}(0)|=4$, что может быть закодировано с помощью четырех $3$-дизъюнктов.)
\end{proof}

\subsection{Верхние Оценки Для Симметрических Функций}\label{upperbound}
Функции четности и голосования являются симметрическими. Напомним, что
булева функция называется симметрической, если ее значение зависит только от суммы (натуральной) входных переменных.
Чтобы закодировать любую симметрическую функцию $f(x_1, \dotsc, x_n)$ в КНФ, можно использовать кострукцию, похожую на~\eqref{eq:blocks}. 
А именно, разделим входные переменные на $t$  дизъюнктивных подмножеств размера не больше $\lceil n/t \rceil$:
$\{x_1, x_2, \dotsc, x_n\}=X_1 \sqcup X_2 \sqcup \dotsb \sqcup X_{t}$.
Пусть $Y_1, \dotsc, Y_t$ будут $t$~подмножеств, каждое из которых состоит из $\lceil \log_2 (n+1) \rceil$ недетерминированных переменных.
Под $Y_i$ будем обозначать биты натурального числа $0 \le y_i \le n$.
Затем запишем с помощью КНФ каждое из следующих тождеств:
\[
\left(y_1 \equiv \sum_{x \in X_1}x\right),
\left(y_2 \equiv y_1+\sum_{x \in X_2}x\right), 
\dotsc,
\left(y_t \equiv y_{t_1}+\sum_{x \in X_t}x\right).
\]
Тогда $y_t$ будет равен~$\sum_{i=1}^nx_i$. То есть с помощью не больше, чем  
$2^{|Y_t|}=2^{\lceil \log_2 (n+1) \rceil} \le 2n$ дополнительных дизъюнктов, мы сможем гарантировать правильное значение для~$f(x_1, \dotsc, x_n)$.
Таким образом, общее число дизъюнктов будет равно

	\[m \le t \cdot \lceil \log_2 (n+1) \rceil \cdot 2^{\lceil n/t\rceil+ \lceil \log_2 (n+1) \rceil} + 2n \, .\]
Мы получили, что для любого натурального~$t$, можно использовать $s=t \cdot \lceil \log_2 (n+1) \rceil$ недетерминированных переменных, чтобы закодировать симметрическую функцию в виде КНФ с
	\[m \le 4 \cdot s \cdot n \cdot 2^{\frac{n (\log n + 1)}{s}} + 2n\]
дизъюнктами.

Известно, что любая симметрическая функция может быть вычислена схемой (над полным бинарным базисом)
размера $4.5n+o(n)$~\cite{DBLP:journals/ipl/DemenkovKKY10}.
Наблюдение~\ref{obs:binarycircuits} дает нам, что любая симметрическая булева функция может быть закодирована в виде~$3$-КНФ 
с $4.5n+o(n)$ недетерминированными переменными и 
$18n+o(n)$ дизъюнктами.
