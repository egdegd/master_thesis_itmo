\section{Основные понятия}

\subsection{Мотивация}
\label{section:generalsetting}

\subsection{Обозначения}

Ниже, мы введем обозначения, которые будут использоваться в этой работе.

\begin{itemize}
	\item $\sqcup$ обозначает дизъюнктивное объединение: используя $A\sqcup B$ вместо $A\cup B$, мы подчеркиваем, что множества $A$~и~$B$ не пересекаются. 
	\item $\oplus$ обозначает сложение по модулю~$2$.
	\item $[n]$ обозначает множество $\{1, 2, \dotsc, n\}$ (в частности, $[2^n] = \{1, 2, \dotsc, 2^n\}$).
	\item $o(\cdot), O(\cdot), \omega(\cdot), \Omega(\cdot), \Theta(\cdot)$ обозначают O~маленькое, 
	O~большое, омегу маленькую, омегу большую, и тету большую, соответственно.
	\item Для функций $f,g \colon \mathbb{Z}_{>0} \to \mathbb{R}_{>0}$, говоря, что $f(n) = 2^{O(g(n))}$, мы подразумеваем, что существует $\alpha > 0$ такая, что
	$f(n) \le 2^{\alpha \cdot g(n)}$ 
	для всех ~$n$.
	\item Для функций $f,g \colon \mathbb{Z}_{>0} \to \mathbb{R}_{>0}$, говоря, что $f(n) = 2^{o(g(n))}$,мы подразумеваем, что для любой константы $\alpha > 0$ существует натуральное число $n_0$ такое, что
	$f(n) \le 2^{\alpha \cdot g(n)}$ 
	для всех~$n > n_0$.
	\item Для функций $f,g \colon \mathbb{Z}_{>0} \to \mathbb{R}_{>0}$, говоря, что $f(n) = 2^{\Omega(g(n))}$, мы подразумеваем, что существует $\alpha > 0$ такая, что 
	$f(n) \ge 2^{\alpha \cdot g(n)}$ 
	для всех~$n$.
	\item Для функций $f,g \colon \mathbb{Z}_{>0} \to \mathbb{R}_{>0}$, говоря, что $f(n) = 2^{\omega(g(n))}$, мы подразумеваем, что для любой константы $\alpha > 0$ существует натуральное число $n_0$ такое, что 
	$f(n) \ge 2^{\alpha \cdot g(n)}$ 
	для всех~$n > n_0$.
\end{itemize}

\subsection{Вычисление булевой функции с помощью КНФ}
Для булевой функции $f(x_1, \dotsc, x_n) \colon \{0,1\}^n \to \{0,1\}$, будем говорить, что КНФ~$F(x_1, \dotsc, x_n)$ \emph{вычисляет~$f$}, если $f \equiv F$, то есть, для всех $x_1, \dotsc, x_n \in \{0,1\}$, $f(x_1, \dotsc, x_n)=F(x_1, \dotsc, x_n)$.
Мы рассматриваем КНФ как набор дизъюнктов, и под \emph{размером} КНФ мы имеем ввиду число дизъюнктов.
Хорошо известно, что для любой функции~$f$ существует КНФ, вычисляющая эту функцию. Один из способов построить такую КНФ выглядит следующим образом: для каждого входа $x \in \{0,1\}^n$ такого, что $f(x)=0$, добавим в КНФ дизъюнкт длины~$n$, который не выполняется входом~$x$.

Этот метод не гарантирует, что полученная КНФ имеет минимальный размер: это было бы слишком хорошо, так как задача поиска КНФ минимального размера для булевой функции (данной в виде таблицы истинности) является NP-трудной, как доказал Масек~\cite{MasekNpComp} (смотри также \cite{DBLP:journals/siamcomp/AllenderHMPS08} и ссылки там).
Например, для функции $f(x_1,x_2)=x_1$, вышеизложенный метод производит КНФ $({x_1} \lor x_2) \land ({x_1} \lor \overline{x_2})$, в то время как сама функция $x_1$ уже в КНФ форме.

Доказано, что для многих функций, минимальная КНФ имеет экспоненциальный размер. Каноническим примером является функция четности $\PAR_n(x_1, \dotsc, x_n)=x_1 \oplus \dotsb \oplus x_n$. Важным свойством $\PAR_n$ является повышенная \emph{чувствительность}: меняя \emph{любой} бит во входе~$x \in \{0,1\}^n$, меняется значение всей функции~$\PAR_n(x)$. Именно из - за этого свойства не может быть маленькой КНФ, вычисляющей функцию $\PAR_n$.

\begin{lemma}\label{lemma:detparity}
	Минимальный размер КНФ, вычисляющей~$\PAR_n$ равен $2^{n-1}$.
\end{lemma}
\begin{proof}
	Верхняя оценка следует из метода, изложенного выше и факта, что $|\PAR_n^{-1}(0)|=2^{n-1}$.
	
	Нижняя оценка основана на факте, что любой дизъюнкт у КНФ~$F$ вычисляющей $\PAR_n$, должен содержать все переменные $x_1, \dotsc, x_n$.
	Действительно, если дизъюнкт $C \in F$ не зависит от переменной~$x_i$, то можно найти вход $x \in \{0,1\}^n$, который опровергает~$C$ (таким образом $F(x)=\PAR_n(x)=0$), и продолжит опровергать $C$ после инвертирования $x_i$. 
	Так как любой дихъюнкт~$F$ имееет ровно $n$ переменных, то он опровергает ровно один вход $x \in \{0,1\}^n$. Следовательно, $F$ должен содержать хотя бы  $|\PAR_n^{-1}(0)|=2^{n-1}$ дизъюнктов.
\end{proof}

\subsection{Кодирование булевой функции с помощью КНФ}\label{sec:encodings}
Будем говорить, что КНФ~$F$ \emph{кодирует} булеву функцию $f(x_1, \dotsc, x_n)$, если следующие два условия выполняются.
\begin{enumerate}
	\item В дополнение ко входным битам $x_1, \dotsc, x_n$, $F$ также зависит от $s$~битов $y_1, \dotsc, y_s$, называемые \emph{недетерминированные входы} or \emph{дополнительные входы}.
	\item Для каждого $x \in \{0,1\}^n$, $f(x)=1$ тогда и только тогда, когда существует $y \in \{0,1\}^s$ такой, что $F(x,y)=1$. Другими словами, для всех $x \in \{0,1\}^n$,
	\begin{equation}\label{eq:enc}
		f(x) = \bigvee_{y \in \{0,1\}^s}F(x,y) \, .
	\end{equation}
\end{enumerate}
Такое представление булевой функции широко используется на практике при переводе задачи в КНФ.
Например, следующая КНФ кодирует $\PAR_4$:
\begin{multline}\label{eq:toyenc}
	(x_1 \lor x_2 \lor \overline{y_1}) \land (x_1 \lor  \overline{x_2} \lor y_1) \land (\overline{x_1} \lor x_2 \lor y_1) \land (\overline{x_1} \lor \overline{x_2} \lor \overline{y_1})
	\land
	(y_1 \lor x_3 \lor \overline{y_2}) \land\\ (y_1 \lor  \overline{x_3} \lor y_2) \land (\overline{y_1} \lor x_3 \lor y_2) \land (\overline{y_1} \lor \overline{x_3} \lor \overline{y_2})
	\land (\overline{x_4} \lor y_2) \land (x_4 \lor \overline{y_2}) \, .
\end{multline}

Этот пример обобщается следующим образом.
Чтобы закодировать $x_1 \oplus \dotsb \oplus x_n$ в виде КНФ,
надо ввести
$s \in \mathbb{Z}_{\ge 0}$~недетерминированных переменных $y_1, \dotsc, y_s$
и разделить множество входных переменных на дизъюнктивные множества размер не более $\lceil n/(s+1) \rceil$: $\{x_1, x_2, \dotsc, x_n\}=X_1 \sqcup X_2 \sqcup \dotsb \sqcup X_{s+1}$. 
Затем запишем следующие $s+1$ булевы функции в виде КНФ:
\begin{multline}\label{eq:blocks}
	\left(y_1 \equiv \bigoplus_{x \in X_1}x\right),
	\left(y_2 \equiv y_1 \oplus \bigoplus_{x \in X_2}x\right), \dotsc,\\
	\left(y_s \equiv y_{s-1} \oplus \bigoplus_{x \in X_s}x\right),
	\left(1 \equiv y_s \oplus \bigoplus_{x \in X_{s+1}}x\right).
\end{multline}
Каждая скобка может быть рассмотрена как булева функция от $k$ переменных, где $k \le \lceil n/(s+1) \rceil + 2$. Каждая такая функция имеет  $2^{k - 1}$ нулей, и поэтому может быть закодирована с помощью $2^{k - 1} \le 2^{\lceil n/(s+1) \rceil+2-1}$ дизъюнктов.
Значение для параметра~$s$ обычно определяется эксперементально. 
Например, Прествич~\cite{DBLP:journals/dam/Prestwich03} говорит, 
что лучший результат при решении задачи "minimal disagreement parity learning", используя САТ-солверы, основанные на локальном поиске, достигается при $s=10$.

Конструкция выше позволяет закодировать функцию четности в виде КНФ со следующей верхней границей на число дизъюнктов $m$, числе недетерминированных переменных~$s$ и ширину дизъюнктов~$k$.
The construction above 
allows one 
\begin{description}
	\item[Limited nondeterminism:] используя $s \in \mathbb{Z}_{\ge 0}$~недетерминированных переменных, можно закодировать функцию четности либо
	как КНФ с не более, чем 
	\begin{equation}\label{eq:upperm}
		m \le (s+1)2^{\lceil n/(s+1) \rceil+1} \le 4(s+1)2^{n/(s+1)}
	\end{equation}
	дизъюнктами, либо как~$k$-КНФ, где
	\begin{equation}\label{eq:upperk}
		k=2+{\lceil n/(s+1) \rceil} \le 3+n/(s+1) \, ,
	\end{equation}
	(следует из~\eqref{eq:blocks}).
	
%	\item[Unlimited nondeterminism:] one can encode parity 
%	as~a~CNF with at~most
%	\begin{equation}\label{eq:uppermtwo}
%		m \le 4n
%	\end{equation}
%	clauses
%	(to~do this, use $s=n-1$ nondeterministic variables; then, each of~$n$~functions in~\eqref{eq:blocks} can be~written in~CNF using at~most four clauses).
\end{description}